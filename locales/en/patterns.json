{
	"id": "patterns",
	"overview": "null",
	"example": {
		"name": "Example",
		"page_1": ["Templates define the model (functions, classes), which types are used; at the time of writing the code, it is not known that these will be typical models. In other words, templates allow you to define generic constructs that are independent of a particular type. A class template (class template) allows you to set the type for objects used in a class. But before we move on to defining the class template, let's look at the problem. Let's say we need to describe the class of a bank account. The bank account must have a number, but at the time of writing the class it may not be known what type the number will be represented - it can be a numeric number 1233545, or it can be just a set of characters in the form of a string, for example, \"1234878rtyio\". At first glance, we can simply define two classes: "
		"<code>#include &lt;iostream&gt; \n#include &lt;string&gt; \nclass IntAccount { \nprivate: \nint id; \npublic: \nIntAccount(int id) : id(id) \n{ } \nint getId() { \nreturn id; \n} \n};  \nclass StrAccount { \nprivate: \nstd::string id; \npublic: \nStrAccount(std::string id) : id(id) \n{ } \nstd::string getId() { \nreturn id; \n} \n};  \nint main() \n { \nStrAccount acc1(\"ca-pub1343767\"); \nIntAccount acc2(1234566); \nstd::cout &lt;&lt; \"acc1:\" &lt;&lt; acc1.getId() &lt;&lt; std::endl; \nstd::cout &lt;&lt; \"acc2: \" &lt;&lt; acc2.getId() &lt;&lt; std::endl; \nreturn 0; \n}</code>"
		"Although this example works, in fact we get two identical classes that differ only in the id type. Class templates can help reduce code repetition by defining a generic type for the class. Let's change the code to apply templates:"
		"<code>template &lt;typename T&gt; \nclass Account { \nprivate: \\nT id; \npublic: \nAccount(T id) : id(id) \n{ } \nT getId() { \nreturn id; \n} \n};</code>"
		"To apply templates, the template keyword is specified before the class, followed by angle brackets. In angle brackets after typename comes the template parameter. You can define multiple template parameters, in the example above, only one parameter is used. The template parameter is an arbitrary identifier, which is usually capitalized, such as T. But this is optional. That is, in this case, the parameter T will represent some type that becomes known at compile time. It can be int, double, string, or any other type. And now the account identifier will represent the type that is passed through the T parameter."
		"<code>#include &lt;&lt;iostream&gt;&gt; \n#include &lt;string&gt; \ntemplate &lt;typename T&gt; \nclass Account { \nprivate: \nT id; \npublic: \nAccount(T id) : id(id) \n{ } \nT getId() { \nreturn id; \n} \n};  \nint main() \n{ \nAccount<std::string> acc1(\"ca-pub1343767\"); \nAccount<int> acc2(1234566); \nstd::cout &lt;&lt; \"acc1: \" &lt;&lt; acc1.getId() &lt;&lt; std::endl; \nstd::cout &lt;&lt; \"acc2: \" &lt;&lt; acc2.getId() &lt;&lt; std::endl; \nreturn 0; \n}</code>"
		"When using a class template, it is necessary in angle brackets after the class name to indicate the specific type that will be used instead of the parameter T. So, in the first case, instead of T, the string type is used, so you can pass the string to the class constructor:"
		"<code>	Account&lt;std::string&gt; acc1(\"ca-pub1343767\");</code>"
		"In the second case, the int type is used, so a number is passed to the constructor:"
		"<code>Account&lt;int&gt; acc2(1234566);</code>"
		"You can also apply multiple parameters at once. For example, you need to define a bank transfer class:"
		"<code>#include &lt;iostream&gt; \n#include &lt;string&gt; \ntemplate &lt;typename T, typename V&gt; \nclass Transaction \n{ \npublic: \nTransaction(T fromAcc, T toAcc, V code, int sum): \nfromAccount(fromAcc), toAccount(toAcc), code(code), sum(sum) \n{ } \nvoid getInfo() \n{ \nstd::cout &lt;&lt; \"From: \" &lt;&lt; fromAccount &lt;&lt; \"\nTo: \" &lt;&lt; toAccount &lt;&lt; \"\nSum: \" &lt;&lt; sum &lt;&lt; \"\nCode: \" &lt;&lt; code &lt;&lt; std::endl; \n} \nprivate: \nT fromAccount;  // from acc \nT toAccount;    // to acc \nV code;         // operation code \nint sum;        // sum of transaction \n}; \nint main() \n{ \nTransaction&lt;std::string, int&gt; t1(\"id1234\", \"id5678\", 2804, 5000); \nt1.getInfo(); \nreturn 0; \n}</code>"
		"The Transaction class uses two parameters, T and V. The T parameter defines the type for the accounts that are involved in the transfer process. Here, you can use both numeric and string values and values of other types as account numbers. And the V parameter specifies the type for the opcode - again, it can be any type. When using a template in this case, you must specify two types:"
		"<code>Transaction&lt;std::string, int&gt; t1(\"id1234\", \"id5678\", 2804, 5000); </code>"
		"Types are passed to parameters by position. So, the string type will be used instead of the T parameter, and the int type will be used instead of the V parameter."
			  ]
	}
