{
	"id": "patterns",
	"overview": "null",
	"example": {
		"name": "Example",
		"page_1": ["Templates define the model (functions, classes), which types are used; at the time of writing the code, it is not known that these will be typical models. In other words, templates allow you to define generic constructs that are independent of a particular type. A class template (class template) allows you to set the type for objects used in a class. But before we move on to defining the class template, let's look at the problem. Let's say we need to describe the class of a bank account. The bank account must have a number, but at the time of writing the class it may not be known what type the number will be represented - it can be a numeric number 1233545, or it can be just a set of characters in the form of a string, for example, \"1234878rtyio\". At first glance, we can simply define two classes: "
		"<code>#include &lt;iostream&gt; \n#include &lt;string&gt; \nclass IntAccount { \nprivate: \nint id; \npublic: \nIntAccount(int id) : id(id) \n{ } \nint getId() { \nreturn id; \n} \n};  \nclass StrAccount { \nprivate: \nstd::string id; \npublic: \nStrAccount(std::string id) : id(id) \n{ } \nstd::string getId() { \nreturn id; \n} \n};  \nint main() \n { \nStrAccount acc1(\"ca-pub1343767\"); \nIntAccount acc2(1234566); \nstd::cout &lt;&lt; \"acc1:\" &lt;&lt; acc1.getId() &lt;&lt; std::endl; \nstd::cout &lt;&lt; \"acc2: \" &lt;&lt; acc2.getId() &lt;&lt; std::endl; \nreturn 0; \n}</code>"
		"Although this example works, in fact we get two identical classes that differ only in the id type. Class templates can help reduce code repetition by defining a generic type for the class. Let's change the code to apply templates:"
		"<code>template &lt;typename T&gt; \nclass Account { \nprivate: \\nT id; \npublic: \nAccount(T id) : id(id) \n{ } \nT getId() { \nreturn id; \n} \n};</code>"
		"To apply templates, the template keyword is specified before the class, followed by angle brackets. In angle brackets after typename comes the template parameter. You can define multiple template parameters, in the example above, only one parameter is used. The template parameter is an arbitrary identifier, which is usually capitalized, such as T. But this is optional. That is, in this case, the parameter T will represent some type that becomes known at compile time. It can be int, double, string, or any other type. And now the account identifier will represent the type that is passed through the T parameter."
		"<code>#include &lt;&lt;iostream&gt;&gt; \n#include &lt;string&gt; \ntemplate &lt;typename T&gt; \nclass Account { \nprivate: \nT id; \npublic: \nAccount(T id) : id(id) \n{ } \nT getId() { \nreturn id; \n} \n};  \nint main() \n{ \nAccount<std::string> acc1(\"ca-pub1343767\"); \nAccount<int> acc2(1234566); \nstd::cout &lt;&lt; \"acc1: \" &lt;&lt; acc1.getId() &lt;&lt; std::endl; \nstd::cout &lt;&lt; \"acc2: \" &lt;&lt; acc2.getId() &lt;&lt; std::endl; \nreturn 0; \n}</code>"
		"When using a class template, it is necessary in angle brackets after the class name to indicate the specific type that will be used instead of the parameter T. So, in the first case, instead of T, the string type is used, so you can pass the string to the class constructor:"
		"<code>	Account&lt;std::string&gt; acc1(\"ca-pub1343767\");</code>"
		"In the second case, the int type is used, so a number is passed to the constructor:"
		"<code>Account&lt;int&gt; acc2(1234566);</code>"
		"You can also apply multiple parameters at once. For example, you need to define a bank transfer class:"
		"<code>#include &lt;iostream&gt; \n#include &lt;string&gt; \ntemplate &lt;typename T, typename V&gt; \nclass Transaction \n{ \npublic: \nTransaction(T fromAcc, T toAcc, V code, int sum): \nfromAccount(fromAcc), toAccount(toAcc), code(code), sum(sum) \n{ } \nvoid getInfo() \n{ \nstd::cout &lt;&lt; \"From: \" &lt;&lt; fromAccount &lt;&lt; \"\nTo: \" &lt;&lt; toAccount &lt;&lt; \"\nSum: \" &lt;&lt; sum &lt;&lt; \"\nCode: \" &lt;&lt; code &lt;&lt; std::endl; \n} \nprivate: \nT fromAccount;  // from acc \nT toAccount;    // to acc \nV code;         // operation code \nint sum;        // sum of transaction \n}; \nint main() \n{ \nTransaction&lt;std::string, int&gt; t1(\"id1234\", \"id5678\", 2804, 5000); \nt1.getInfo(); \nreturn 0; \n}</code>"
		"The Transaction class uses two parameters, T and V. The T parameter defines the type for the accounts that are involved in the transfer process. Here, you can use both numeric and string values and values of other types as account numbers. And the V parameter specifies the type for the opcode - again, it can be any type. When using a template in this case, you must specify two types:"
		"<code>Transaction&lt;std::string, int&gt; t1(\"id1234\", \"id5678\", 2804, 5000); </code>"
		"Types are passed to parameters by position. So, the string type will be used instead of the T parameter, and the int type will be used instead of the V parameter."]
	}
	"id": "patterns",
	"overview": "In addition to class templates, we can use function templates. For example, consider the following example:",
	"example": {
	"name": "Example",
	"page_2":[
		"<code>#include &lt;iostream&gt; \nint add(int x, int y) \n{ \nreturn x + y; \n} \ndouble add(double x, double y) \n { \nreturn x + y; \n} \nint main() \n{ \ndouble n1 = add(4.7, 5.3);  // 10 \nint n2 = add(4, 5);     // 9 \nstd::cout &lt;&lt; \"n1: \" &lt;&lt; n1 &lt;&lt; std::endl;  \nstd::cout &lt;&lt; \"n2: \" &lt;&lt; n2 &lt;&lt; std::endl;     \nreturn 0; \n} </code>"
		"This example works great, does the calculations as it should. However, in this case, we are faced with the fact that the add function is actually duplicated. Both versions of it actually perform the same action, the only difference is the type of the parameters and the return value: in one case, it is an int type, and in the other, it is a double type. Now let's apply the function templates. Function templates provide some pattern by which you can create a specific function specific to a particular type:"
		"<code>#include &lt;iostream&gt;  \ntemplate&lt;typename T&gt; \nT add(T x, T y) \n{ \nreturn x + y; \n} \nint main() \n{ \ndouble a1 = 4.7, b1 = 5.3; \ndouble n1 = add(a1, b1); \nint a2 = 4, b2 = 5; \mint n2 = add(a2, b2); \nshort a3 = 3, b3 = 2; \nshort n3 = add(a3, b3); \nstd::cout &lt;&lt; \"n1: \" &lt;&lt; n1 &lt;&lt; std::endl; \nstd::cout &lt;&lt; \"n2: \" &lt;&lt; n2 &lt;&lt; std::endl; \nstd::cout &lt;&lt; \"n3: \" &lt;&lt; n3 &lt;&lt; std::endl; \nreturn 0; \n}</code>"
		"The definition of a function template, like a class template, begins with the <b>template</b> keyword followed by angle brackets. In angle brackets after <b>typename</b> comes the template parameter. You can define multiple template parameters, in the example above, only one parameter is used. But in this case, it is important that the type that will be used instead of the parameter T supports the addition operation, which would return an object of the same type. If suddenly the type used does not apply the addition operation, then at the compilation stage we will encounter an error. And when you call the add function, you can pass objects of the int type, and of the double type, and any other type to it. When the function is called, the compiler will infer the specific type associated with the template parameter T. based on the type of the arguments. Another example is the value exchange function:"
		"<code>#include &lt;iostream&gt; \ntemplate &lt;typename T&gt; \nvoid swap(T& a, T& b) \n{ \nT temp = a; \na = b; \nb = temp; \n} \nint main() \n{ \nint c = 30; \nint d = 10; \nswap(c, d); \nstd::cout &lt;&lt; \"c = \" &lt;&lt; c &lt;&lt;\"\t d = \" &lt;&lt; d &lt;&lt; std::endl; \nreturn 0; \n}</code>"
		"The swap function takes two parameters of any type and changes their values. Several parameters can be used:"
		"<code>#include &lt;iostream&gt; \n#include &lt;string&gt; \ntemplate &lt;typename T, typename K&gt; \nvoid transact(T fromAcc, T toAcc, K code, int sum) \n{ \nstd::cout &lt;&lt; \"From: \" &lt;&lt; fromAcc &lt;&lt; \"\nTo: \" &lt;&lt; toAcc &lt;&lt; \"\nSum: \" &lt;&lt; sum &lt;&lt; \"\nCode: \" &lt;&lt; code &lt;&lt; std::endl; \n} \nint main() \n{ \ntransact(\"id1234\", \"id5678\", 2804, 5000);  \nreturn 0; \n}</code>"
		"In this case, when calling transact (\"id1234\", \"id5678\", 2804, 5000); instead of the T parameter, the string type will be substituted, and instead of the K parameter, the int type."
}
