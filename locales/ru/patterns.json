{
	"id": "patterns",
	"name": "<b>Шаблоны</b>",
	"overview": "В этом разделе объясняются концепции, которые имеют решающее значение для понимания <b>шаблонов</b>.",
	"class_template": 
	{
		"name": "Class template",
		"page_1":
		[
			"Шаблоны позволяют определить конструкции (функции, классы), которые используют определенные типы, но на момент написания кода точно не известно, что это будут за типы. Иными словами, шаблоны позволяют определить универсальные конструкции, которые не зависят от определенного типа. \nШаблон класса (class template) позволяет задать тип для объектов, используемых в классе. Но прежде чем перейти к определению шаблона класса, рассмотрим проблему, с которой мы можем столкнуться и которую позволяют решить шаблоны. \nДопустим, нам надо описать класс банковского счета. Банковский счет должен иметь номер, однако на момент написания класса может быть неизвестно, какой тип будет представлять номер счета - это может быть числовой номер 1233545, а может и быть просто набор символов в виде строки, например, '1234878rtyio'. На первый взгляд, мы можем просто определить два класса:",
			"<code>#include &lt;iostream&gt; \n#include &lt;string&lt; \nclass IntAccount { \nprivate: \nint id; \npublic: \nIntAccount(int id) : id(id) \n{ } \nint getId() { \nreturn id; \n} \n}; \nclass StrAccount { \nprivate: \nstd::string id; \npublic: \nStrAccount(std::string id) : id(id) \n{ } \nstd::string getId() { \nreturn id; \n} \n}; \nint main() \n{ \nStrAccount acc1('ca-pub1343767'); \nIntAccount acc2(1234566); \nstd::cout &lt;&lt; 'acc1: ' &lt;&t; acc1.getId() &lt;&lt; std::endl; \nstd::cout  'acc2: ' &lt;&lt; acc2.getId() &lt;&lt; std::endl; \nreturn 0; \n}</code> \nХотя данный пример работает, но по сути мы получаем два идентичных класса, которые отличаются только типом id. Шаблоны класса позволяют уменьшить повторяемость кода, задав для класса универсальный тип. Изменим код, применив шаблоны:",
			"<code>template &lt;typename T&gt; \nclass Account { \nprivate: \nT id; \npublic: \nAccount(T id) : id(id) \n{ } \nT getId() { \nreturn id; \n} \n};</code> \nДля применения шаблонов перед классом указывается ключевое слово <b>template</b>, после которого идут угловые скобки. В угловых скобках после слова <b>typename</b> идет параметр шаблона. Можно определить несколько параметров шаблона, в примере выше применяется только один параметр. \nПараметр шаблона представляет произвольный идентификатор, в качестве которого, как правило, применяюся заглавные буквы, например, T. Но это необязательно. То есть в данном случае параметр T будет представлять некоторый тип, который становится известным во время компиляции. Это может быть и тип int, и double, и string, и любой другой тип. И теперь идентификатор счета будет представлять тип, который передается через параметр T. \nИспользуем этот класс:",
			"<code>#include &lt;iostream&gt; \n#include &lt;string&gt; \ntemplate &lt;typename T&gt; \nclass Account { \nprivate: \nT id; \npublic: \nAccount(T id) : id(id) \n{ } \nT getId() { \nreturn id; \n} \n}; \nint main() \n{ \nAccount&lt;std::string&gt; acc1('ca-pub1343767'); \nAccount&lt;int&gt; acc2(1234566); \nstd::cout &lt;&lt; 'acc1: ' &lt;&lt; acc1.getId() &lt;&lt; std::endl; \nstd::cout &lt;&lt; 'acc2: ' &lt;&lt; acc2.getId() &lt;&lt; std::endl;  \nreturn 0; \n}</code> \nПри использовании шаблона класса необходимо в угловых скобках после названия класса указать конкретный тип, который будет применяться вместо параметра T. Так, в первом случае вместо T применяется тип string, поэтому в конструктор класса можно передать строку: \n<code>Account<std::string> acc1('ca-pub1343767');</code> \nВо втором случае применяется тип int, поэтому в конструктор передается число: \n<code>Account<int> acc2(1234566);</code>",
			"Также можно применять сразу несколько параметров. Например, необходимо определить класс банковского перевода: \n<code>#include &lt;iostream&gt; \n#include &lt;string&gt: \ntemplate &lt;typename T, typename V&gt; \nclass Transaction \n{ \npublic: \nTransaction(T fromAcc, T toAcc, V code, int sum): \nfromAccount(fromAcc), toAccount(toAcc), code(code), sum(sum) \n{ } \nvoid getInfo() \n{ \nstd::cout &lt;&lt; 'From: ' &lt;&lt; fromAccount &lt;&lt; '\nTo: ' &lt;&lt; toAccount \n&lt;&lt; '\nSum: ' &lt;&lt; sum &lt;&lt; '\nCode: ' &lt;&lt; code &lt;&lt; std::endl; \n} \nprivate: \nT fromAccount;  // с какого счета \nT toAccount;    // на какой счет \nV code;         // код операции \nint sum;        // сумма перевода \n}; \nint main() \n{ \nTransaction&lt;std::string, int&gt; t1('id1234', 'id5678', 2804, 5000); \nt1.getInfo(); \nreturn 0; \n}</code>",
			"Класс Transaction использует два параметра типа T и V. Параметр T определяет тип для счетов, которые участвуют вв процессе перевода. Здесь в качестве номеров счетов можно использовать и числовые и строковые значения и значения других типов. А параметр V задает тип для кода операции - опять же это может быть любой тип. \nПри использовании шаблона в этом случае надо указать два типа: \n<code>Transaction<std::string, int> t1('id1234', 'id5678', 2804, 5000);</code> \nТипы передаются параметрам по позиции. Так, тип string будет использоваться вместо параметра T, а тип int - вместо параметра V."
		]
	},
	
	"function_templates":
	{
		"name": "Шаблоны функций",
		"page_1":
		[
			"Кроме шаблонов классов мы можем применять шаблоны функций (function template). Например, рассмотрим следующий пример: \n<code>#include &lt;iostream&gt; \nint add(int x, int y) \n{ \nreturn x + y; \n} \ndouble add(double x, double y) \n{ \nreturn x + y; \n} \nint main() \n{ \ndouble n1 = add(4.7, 5.3);  // 10 \nint n2 = add(4, 5);     // 9 \nstd::cout &lt;&lt; 'n1: ' &lt;&lt; n1 &lt;&lt; std::endl; \nstd::cout &lt;&lt; 'n2: ' &lt;&lt; n2 &lt;&lt; std::endl; \nreturn 0; \n}</code> \nДанный пример отлично работает, производит вычисления, как и должен. Однако в данном случае мы сталкиваемся с тем, что функция add фактически дублируется. Обе ее версии фактически выполняют одно и то же действие, единственно что отличается тип параметров и возвращаемого значения: в одном случае это тип int, а в другом - тип double. \nТеперь применим шаблоны функций. Шаблоны функций представляют некоторый образец, по которому можно создать конкретную функцию, специфическую для определенного типа:",
			"<code>#include &lt;iostream&gt; \ntemplate&lt;typename T&gt; \nT add(T x, T y) \n{ \nreturn x + y; \n} \nint main() \n{ \ndouble a1 = 4.7, b1 = 5.3; \ndouble n1 = add(a1, b1); \nint a2 = 4, b2 = 5; \nint n2 = add(a2, b2); \nshort a3 = 3, b3 = 2; \nshort n3 = add(a3, b3); \n    std::cout &lt;&lt; 'n1: '  n1 &lt;&lt; std::endl; \nstd::cout &lt;&lt; 'n2: ' &lt;&lt; n2 &lt;&lt; std::endl; \nstd::cout &lt;&lt; 'n3: ' &lt;&lt; n3 &lt;&lt; std::endl; \n    return 0; \n}</code> \nОпределение шаблона функции, как и шаблона класса, начинается с ключевого слова <b>template</b>, после которого указываются угловые скобки. В угловых скобках после слова <b>typename</b> идет параметр шаблона. Можно определить несколько параметров шаблона, в примере выше применяется только один параметр. Но в данном случае важно, чтоб тип, который будет применяться вместо параметра T, поддерживал операцию сложения, которая возвращала бы объект этого же типа. Если вдруг используемый тип не будет применять операцию сложения, то на этапе компиляции мы столкнемся с ошибкой.",
			"И при вызове функции add в нее можно передавать объекты и типа int, и типа double, и любого другого типа. При вызове функции компилятор на основании типа аргументов выведет конкретный тип, связанный с параметром шаблона T. \nДругой пример - функция обмена значениями: \n<code>#include &lt;iostream&gt; \ntemplate &lt;typename T&gt; \nvoid swap(T& a, T& b) \n{ \nT temp = a; \na = b; \nb = temp; \n} \nint main() \n{ \nint c = 30; \nint d = 10; \nswap(c, d); \nstd::cout &lt;&lt; 'c = ' &lt;&lt; c &lt;&lt; '\t d = ' &lt;&lt; d << std::endl; \nreturn 0; \n}</code> \nФункция swap принимает два параметра любого типа и меняет их значения. \nМожно использовать несколько параметров:",
			"<code>#include &lt;iostream&gt; \n#include &lt;string&gt; \ntemplate &lt;typename T, typename K&gt; \nvoid transact(T fromAcc, T toAcc, K code, int sum) \n{ \nstd::cout  'From: ' &lt;&lt; fromAcc &lt;&lt; '\nTo: ' &lt;&lt; toAcc \n&lt;&lt; '\nSum: ' &lt;&lt; sum &lt;&lt; '\nCode: ' &lt;&lt; code &lt;&lt; std::endl; \n} \nint main() \n{ \ntransact('id1234', 'id5678', 2804, 5000); \nreturn 0; \n}</code> \nВ данном случае при вызове transact('id1234', 'id5678', 2804, 5000); вместо параметра T будет подставляться тип string, а вместо параметра K - тип int."
		]
	}
 

}
