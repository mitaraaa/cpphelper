{
	"id": "pointers",
	"name": "<b>Pointers</b>",
	"overview": "В этом разделе объясняются концепции, которые имеют решающее значение для понимания указателей</b>",

	"definition":
	{
		"name": "Определение",
		"page_1":

		[
			"Указатели представляют собой объекты, значением которых служат адреса других объектов (переменных, констант, указателей) или функций. Как и ссылки, указатели применяются для косвенного доступа к объекту. Однако в отличие от ссылок указатели обладают большими возможностями.",
			"Для определения указателя надо указать тип объекта, на который указывает указатель, и символ звездочки *. Например, определим указатель на объект типа int: \n<code>int *p;</code> \nПока указатель не ссылается ни на какой объект. При этом в отличие от ссылки указатель необязательно инициализировать каким-либо значением. Теперь присвоим указателю адрес переменной:",
			"<code>int x = 10; // определяем переменную \nint *p; // определяем указатель \np = &x; // указатель получает адрес переменной</code> \nДля получения адреса переменной применяется операция &amp. Что важно, переменная x имеет тип int, и указатель, который указывает на ее адрес, тоже имеет тип int. То есть должно быть соответствие по типу.",
			"Если мы попробуем вывести адрес переменной на консоль, то увидим, что он представляет шестнадцатиричное значение: \n<code>#include &lt;iostream&gt; \nint main() \n{ \nint x = 10; // определяем переменную \nint *p; // определяем указатель \np = &x; // указатель получает адрес переменной \nstd::cout &lt;&lt; 'p = ' &lt;&lt; p &lt;&lt; std::endl; \nreturn 0; \n}</code>",
			"Консольный вывод программы: \n<b>p = 0x60fe98</b> \nВ каждом отдельном случае адрес может отличаться, но к примеру, в моем случае машинный адрес переменной x - 0x60fe98. То есть в памяти компьютера есть адрес 0x60fe98, по которому располагается переменная x. Так как переменная x представляет тип int, то на большинстве архитектур она будет занимать следующие 4 байта (на конкретных архитектурах размер памяти для типа int может отличаться). Таким образом, переменная типа <b>int</b> последовательно займет ячейки памяти с адресами 0x60FE98, 0x60FE99, 0x60FE9A, 0x60FE9B.",
			"И указатель <b>p</b> будет ссылаться на адрес, по которому располагается переменная x, то есть на адрес 0x60FE98. \nНо так как указатель хранит адрес, то мы можем по этому адресу получить хранящееся там значение, то есть значение переменной x. Для этого применяется операция <b>*</b> или операция разыменования, то есть та операция, которая применяется при определении указателя. Результатом этой операции всегда является объект, на который указывает указатель. Применим данную операцию и получим значение переменной x:",
			"<code>#include &lt;iostream&gt; \nint main() \n{ \nint x = 10; \nint *p; \np = &x; \nstd::cout &lt;&lt; 'Address = ' &lt;&lt; p &lt;&lt; std::endl; \nstd::cout &lt;&Lt; 'Value = ' &lt;&lt; *p &lt;&lt; std::endl; \nreturn 0; \n}</code> \nКонсольный вывод: \n<b>Address = 0x60fe98 \nValue = 10</b> \nЗначение, которое получено в результате операции разыменования, можно присвоить другой переменной:",
			"<code>int x = 10; \nint *p  = &x; \nint y = *p; \nstd::cout &lt;&lt; 'Value = ' &lt;&lt; y &lt;&lt; std::endl;    // 10</code> \nИ также используя указатель, мы можем менять значение по адресу, который хранится в указателе:",
			"<code>int x = 10; \nint *p = &x; \n*p = 45; \nstd::cout &lt;&lt; 'x = ' &lt;&lt; x &lt;&lt; std::endl;     // 45</code> \nТак как по адресу, на который указывает указатель, располагается переменная x, то соответственно ее значение изменится. \nСоздадим еще несколько указателей:",
			"<code>#include &lt;iostream&gt; \nint main() \n{ \nshort c = 12; \nint d = 10; \nshort s = 2; \nshort *pc = &ampc;          // получаем адрес переменной с типа short \nint *pd = &ampd;           // получаем адрес переменной d типа int \nshort *ps = &amps;         // получаем адрес переменной s типа short \nstd::cout &lt;&lt; 'Variable c: address=' &lt;&lt; pc &lt;&lt; '\t value=' &lt;&lt; *pc &lt;&lt; std::endl; \nstd::cout &lt;&lt; 'Variable d: address=' &lt;&lt; pd &lt;&lt; '\t value=' &lt;&lt; *pd &lt;&lt; std::endl; \nstd::cout &lt;&lt; 'Variable s: address=' &lt;&lt; ps &lt;&lt; '\t value=' &lt;&lt; *ps &lt;&lt; std::endl; \nreturn 0; \n}</code>",
			"В моем случае я получу следующий консольный вывод: \n<b>Variable c: address=0x60fe92	value=12 \nVariable d: address=0x60fe8c	value=10 \nVariable s: address=0x60fe8a	value=2</b>"
		],

		"page_2":
		[
			"<b>Операции с указателями</b> \nУказатели поддерживают ряд операций: присваивание, получение адреса указателя, получение значения по указателю, некоторые арифметические операции и операции сравнения.",
			"<b>Присваивание</b> \nУказателю можно присвоить либо адрес объекта того же типа, либо значение другого указателя. \nПрисвоение указателю адреса уже рассматривалось в прошлой теме. Для получения адреса объекта используется операция <b>&</b>:",
			"<code>int a = 10; \nint *pa = &ampa; // указатель pa хранит адрес переменной a</code> \nПри этом указатель и переменная должны иметь один и тот же тип, в данном случае это тип int. \nПрисвоение указателю другого указателя:",
			"<code>#include &lt;iostream&gt; \nusing std::cout; \nusing std::endl; \nint main() \n{ \nint a = 10; \nint b = 2; \nint *pa = &ampa; \nint *pb = &ampb; \ncout &lt;&lt; 'Variable a: address=' &lt;&Lt; pa &lt;&lt; '\t value=' &lt;&Lt; *pa &lt;&Lt; endl; \ncout &Lt;&Lt; 'Variable b: address=' &lt;&Lt; pb &lt;&Lt; '\t value=' &lt;&lt; *pb &lt;&lt; endl; \npa = pb;    // теперь указатель pa хранит адрес переменной b \ncout &lt;&lt; 'Variable b: address=' &lt;&lt; pa &lt;&lt; '\t value=' &lt;&lt; *pa &lt;&lt; endl; \nreturn 0; \n}</code>",
			"Когда указателю присваивается другой указатель, то фактически первый указатель начинает также указывать на тот же адрес, на который указывает второй указатель. \n<b>Нулевые указатели</b> \nНулевой указатель (null pointer) - это указатель, который не указывает ни на какой объект. Если мы не хотим, чтобы указатель указывал на какой-то конкретный адрес, то можно присвоить ему условное нулевое значение. Для создания нулевого указателя можно применять различные способы:",
			"<code>int *p1 = nullptr; \nint *p2 = NULL; \nint *p3 = 0;</code> \n<b>Ссылки на указатели</b> \nТак как ссылка не является объектом, то нельзя определить указатель на ссылку, однако можно определить ссылку на указатель. Через подобную ссылку можно изменять значение, на которое указывает указатель или изменять адрес самого указателя:",
			"<code>#include &lt;iostream&gt; \nint main() \n{ \nint a = 10 \nint b = 6; \nint *p = 0; // указатель \nint *&amppRef = p; // ссылка на указатель \npRef = &ampa; // через ссылку указателю p присваивается адрес переменной a \nstd::cout &lt;&lt; 'p value=' &lt;&lt; *p &lt;&lt; std::endl; // 10 \n*pRef = 70; // изменяем значение по адресу, на который указывает указатель \nstd::cout &lt;&lt; 'a value=' &lt;&Lt; a &Lt;&Lt; std::endl; // 70 \npRef = &b; // изменяем адрес, на который указывает указатель \nstd::cout &lt;&lt; 'p value=' &lt;&lt; *p &lt;&Lt; std::endl; // 6 \nreturn 0; \n}</code>"
		],

		"page_3":
		[
			"<b>Разыменование указателя</b> \nОперация разыменования указателя представляет выражение в виде *имя_указателя. Эта операция позволяет получить объект по адресу, который хранится в указателе.",
			"<code>#include &lt;iostream&gt; \nusing std::cout; \nusing std::endl; \nint main() \n{ \nint a = 10; \nint *pa = &a; \nint *pb = pa; \n*pa = 25; \ncout &lt;&lt; 'Value on pointer pa: ' &lt;&lt; *pa &lt;&lt; endl;  // 25 \ncout &lt;&lt; 'Value on pointer pb: ' &lt;&lt; *pb &lt;&lt; endl;  // 25 \ncout &lt;&lt; 'Value of variable a: ' &lt;&lt; a &lt;&lt; endl;    // 25 \nreturn 0; \n}</code>",
			"Через выражение *pa мы можем получить значение по адресу, который хранится в указателе pa, а через выражение типа *pa = значение вложить по этому адресу новое значение. \nИ так как в данном случае указатель pa указывает на переменную a, то при изменении значения по адресу, на который указывает указатель, также изменится и значение переменной a.",
			"<b>Адрес указателя</b> \nУказатель хранит адрес переменной, и по этому адресу мы можем получить значение этой переменной. Но кроме того, указатель, как и любая переменная, сам имеет адрес, по которому он располагается в памяти. Этот адрес можно получить также через операцию <b>&amp</b>:",
			"<code>int a = 10; \nint *pa = &ampa; \nstd::cout &lt;&lt; 'address of pointer=' &lt;&lt; &amppa &lt;&lt; std::endl; // адрес указателя \nstd::cout &lt;&lt; 'address stored in pointer=' &lt;&lt; pa &lt;&lt; std::endl; // адрес, который хранится в указателе - адрес переменной a          \nstd::cout &lt:&lt; 'value on pointer=' &lt;&lt; *pa &lt;&Lt; std::endl; // значение по адресу в указателе - значение переменной a</code>",
			"<b>Операции сравнения</b> \nК указателям могут применяться операции сравнения <b>&gt;, &gt;=, &lt;, &lt;=,==, !=</b> Операции сравнения применяются только к указателям одного типа и к значениям <b>NULL</b> and <b>nullptr</b>. Для сравнения используются номера адресов:",
			"<code>#include &lt;iostream&gt; \nusing std::cout; \nusing std::endl; \nint main() \n{ \nint a = 10; \nint b = 20; \nint *pa = &ampa; \nint *pb = &ampb; \nif(pa &gt; pb) \ncout &lt;&lt; 'pa (' &lt;&lt; pa &lt;&lt; ') is greater than pb ('&lt;&lt; pb &lt;&lt; ')' &lt;&lt; endl; \nelse \ncout &lt;&lt; 'pa (' &lt;&lt; pa &lt;&lt; ') is less or equal pb ('&lt;&lt; pb &lt;&lt; ')' &lt;&lt; endl; \nreturn 0; \n}</code>",
			"Консольный вывод в моем случае: \n<b>pa (0x60fe94) is greater than pb (0x60fe90)</b> \n<b>Приведение типов</b> \nИногда требуется присвоить указателю одного типа значение указателя другого типа. В этом случае следует выполнить операцию приведения типов с помощью операции (тип_указателя *): \n<code>#include &lt;iostream&gt; \nint main() \n{ \nchar c = 'N'; \nchar *pc = &ampc; \nint *pd = (int *)pc; \nvoid *pv = (void*)pc; \nstd::cout &lt;&lt; 'pv' &lt;&Lt; pv &lt;&lt; std::endl; \nstd::cout &lt;&lt; 'pd=' &lt;&lt; pd &Lt;&Lt; std::endl; \nreturn 0; \n}</code>",
			"Для преобразования указателя к другому типу в скобках перед указателем ставится тип, к которому надо преобразовать. Причем если мы не можем просто создать объект, например, переменную типа void, то для указателя это вполне будет работать. То есть можно создать указатель типа void. \nКроме того, следует отметить, что указатель на тип char (char *pc = &ampc) при выводе на консоль система интерпретирует как строку: <code>std::cout &lt;&lt; 'pc=' &lt;&lt; pc &lt;&lt; std::endl;</code>",
			"Поэтому если мы все-таки хотим вывести на консоль адрес, который хранится в указателе типа char, то это указатель надо преобразовать к другому типу, например, к void* или к int*."
		]
	}

}
